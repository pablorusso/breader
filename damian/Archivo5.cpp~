#include "Archivo5.h"

Archivo5::Archivo5(const t_idcat &MAX_CAT): MAX_CAT(MAX_CAT) {
	// Leo/Creo el Archivo5
	this->f.open(A5_PATH, ios::in |ios::out | ios::binary);
	if (this->f.good()) {
		// leo el header
		this->readHeader();
 	} else {
		// El archivo no estaba creado, entonces, lo creo
		// escribo el header por primera vez (no puedo usar writeHeader)
		t_headerArchivo5 header;
		this->f.open(A5_PATH, ios::out | ios::binary);
		this->header.primerLibre = header.primerLibre = A5_SIZEOF_HEADER;
		this->f.write(reinterpret_cast<const char *>(&this->header.primerLibre),
		  sizeof(t_offset));
		// Lo reabro para que sirva para entrada/salida
		this->f.close();
		this->f.open(A5_PATH, ios::in |ios::out | ios::binary);
	}
	// Seteo para que arroje excepciones
	this->f.exceptions(fstream::eofbit | fstream::failbit | fstream::badbit);
}

Archivo5::~Archivo5() {
	try {
		this->writeHeader();
		this->f.close();
	}
	catch (fstream::failure e){
		// aca no se puede hacer nada
	}
}

t_offset Archivo5::writeReg(t_regArchivo5 &reg) {
	t_offset ret;
	try {
		// El writeReg tambien me modificara mi primerLibre, de ser necesario
		ret = reg.writeReg(this->f, this->header.primerLibre);
	}
	catch (fstream::failure e) {
		THROW(eArchivo5, A5_ARCHIVO_CORRUPTO);
	}
	return ret;
}

t_offset Archivo5::writeReg(const string &uri, const string &name) {
	t_offset ret;
	try {
		t_regArchivo5 reg(this->MAX_CAT);
		reg.estado = OCUPADO;
		reg.name = name;
		reg.uri = uri;
		ret = reg.writeReg(this->f, this->header.primerLibre);
	}
	catch (fstream::failure e) {
		THROW(eArchivo5, A5_ARCHIVO_CORRUPTO);
	}
	return ret;
}

t_offset Archivo5::writeReg(const Feed &feed) {
	t_offset ret;
	try {
		t_regArchivo5 reg(this->MAX_CAT);
		reg.estado = OCUPADO;
		reg.name = feed.getName();
		reg.uri = feed.getUri();
		reg.cont = feed.getContIdCat();
		ret = reg.writeReg(this->f, this->header.primerLibre);
	}
	catch (fstream::failure e) {
		THROW(eArchivo5, A5_ARCHIVO_CORRUPTO);
	}
	return ret;
}

t_regArchivo5 Archivo5::readReg(const t_offset &offset) {
	t_regArchivo5 reg(this->MAX_CAT);
	try {
		reg.readReg(f,offset);
	}
	catch (fstream::failure e) {
		THROW(eArchivo5, A5_ARCHIVO_CORRUPTO);
	}
	return reg;
}

bool Archivo5::remReg(const t_offset &offset) {
	bool ret = false;
	try {
		t_regArchivo5 regRem(this->MAX_CAT);
		ret = regRem.remReg(this->f, offset, this->header.primerLibre);
	}
	catch (fstream::failure e) {
		THROW(eArchivo5, A5_ARCHIVO_CORRUPTO);
	}
	return ret;
}

void Archivo5::writeCat(const t_offset &offset, const t_idcat &idcat,
  const bool si_no) {
	if (idcat < this->MAX_CAT) {
		t_idcat d, m;
		unsigned char byte;
		t_offset back;
		d = idcat / 8;
		m = idcat % 8;
		// me posiciono con el put en el byte a modificar
		this->f.seekp(offset+sizeof(bool)+sizeof(t_freeBytes)+d, ios::beg);
		// guardo el offset para un futuro
		back = this->f.tellp();
		// me posiciono con el get en el byte a modificar
		this->f.seekg(back, ios::beg);
		// leo el byte a modificar
		this->f.read(reinterpret_cast<char *>(&byte), sizeof(unsigned char));
		// modifico el byte leido
		bitOperator::setBit(byte, m, si_no);
		// escribo el byte modificado
		f.seekp(back, ios::beg); // No deberia hacer falta
		this->f.write(reinterpret_cast<const char *>(&byte),
		  sizeof(unsigned char));
	} else THROW(eArchivo5, A5_IDCAT_FUERA_DE_RANGO);
}

void Archivo5::writeHeader() {
	this->f.seekp(0, ios::beg);
	this->f.write(reinterpret_cast<const char *>(&this->header.primerLibre),
	  sizeof(t_offset));
}

void Archivo5::readHeader() {
	this->f.seekg(0, ios::beg);
	this->f.read(reinterpret_cast<char *>(&this->header.primerLibre),
	  sizeof(t_offset));
}

ostream &operator<<(ostream &stream,  Archivo5 &a) {
	stream << "Imprimiendo contenido Archivo5" << endl;
	stream << "primerLibre: " << a.header.primerLibre << endl;
	return stream;
}
